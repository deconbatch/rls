#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

def args_parse
  options = ""
  paths   = []
  end_option = false



  for arg in ARGV
    if (arg.to_s == "--")
      end_option = true
      next
    end

    if (!end_option)
      if (arg.slice(0, 1) == "-" && arg.length > 1)
        options += arg
      else
        paths << arg
      end
    else
      paths << arg
    end
  end

  paths << "./" if (paths.length == 0)
  return options, paths

end

# ----------------------------------------------------------------------

def calc_rownum(files, screen_width, col_margin)

  # 行数 1 から最大ファイル数までで画面幅に収まる最小行数を求める
  no_row = 0
  for no_row in  1..files.length do

    #  p '---'
    #  p no_row

    overflow = false
    row_ary = []
    files.each_slice(no_row) { |ary|
      row_ary << ary
    }

    for index_row in (0..no_row-1) do
      length_row = 0
      for row in row_ary do
        length_row += row[index_row] ? row[index_row].to_s.length + col_margin : 0
      end

      #    p screen_width, length_row

      if (length_row > screen_width)
        overflow = true
        break
      end
      
    end

    if (!overflow)
      break
    end
    
  end

  return no_row

end

# ----------------------------------------------------------------------
class List_Printer

require 'etc'
require 'date'

FTYPE = {
  "file"             => "-",
  "directory"        => "d",
  "characterSpecial" => "c",
  "blockSpecial"     => "b",
  "fifo"             => "p",
  "link"             => "l",
  "socket"           => "s",
}

FMODE = {
  "7" => "rwx",
  "6" => "rw-",
  "5" => "r-x",
  "4" => "r--",
  "3" => "-wx",
  "2" => "-w-",
  "1" => "--x",
  "0" => "---",
}

def print_files(dir = "", files)

if (files.length == 0)
  puts "total 0"
  return nil
end

# ディレクトリの末尾を / にする
if (dir != "")
  dir += (dir[-1, 1] == "/") ? "" : "/"
end

block_total = 0
stats = []
len_nlink = 0
len_uname = 0
len_gname = 0
len_size  = 0

files.each do |item|

  f = dir.to_s + item.to_s

  # ファイルにアクセス可能かテスト
  begin
    stat = File.stat(f)
  rescue
    len_nlink = 1
    len_uname = 1
    len_gname = 1
    len_size  = 1

  stats << {
    type:  "-",
    mode:  "?????????",
    nlink: "?",
    uname: "?",
    gname: "?",
    size:  "?",
    date:  "           ?",
    name:  item,
  }
    
    next
  end
=begin
  # ファイルにアクセス可能かテスト
  if (!FileTest.readable?(f))
    len_nlink = 1
    len_uname = 1
    len_gname = 1
    len_size  = 1

  stats << {
    type:  "-",
    mode:  "?????????",
    nlink: "?",
    uname: "?",
    gname: "?",
    size:  "?",
    date:  "           ?",
    name:  item,
  }
    
    next
  end
=end

  stat = File.stat(f)
  f_name = item
  if (File.ftype(f) == "link")
    stat = File.lstat(f)
    f_name = item.to_s + " -> " + File.readlink(f)
  end

  block_total += stat.blocks

  f_type = (FTYPE.has_key?(File.ftype(f))) ? FTYPE[File.ftype(f)] : " "

  f_mode = FMODE[stat.mode.to_s(8)[-3, 1]] + FMODE[stat.mode.to_s(8)[-2, 1]] + FMODE[stat.mode.to_s(8)[-1, 1]]
  case stat.mode.to_s(8)[-4, 1]
  when "1"
    # sticky bit
    f_mode[-1, 1] = "t"
  when "2"
    # setgid
    f_mode[-4, 1] = "s"
  when "4"
    # setuid
    f_mode[-7, 1] = "s"
  end

  f_nlink = stat.nlink
  f_uname = Etc.getpwuid(stat.uid).name
  f_gname = Etc.getgrgid(stat.gid).name
  f_size  = stat.size

  date_format = ((Date.today - stat.mtime.to_date).abs > 181) ? "%b %e %_5Y" : "%b %e %H:%M"
  f_date = stat.mtime.strftime(date_format)

  len_nlink = (f_nlink.to_s.length > len_nlink) ? f_nlink.to_s.length : len_nlink
  len_uname = (f_uname.to_s.length > len_uname) ? f_uname.to_s.length : len_uname
  len_gname = (f_gname.to_s.length > len_gname) ? f_gname.to_s.length : len_gname
  len_size  = (f_size.to_s.length > len_size) ? f_size.to_s.length : len_size

  stats << {
    type:  f_type,
    mode:  f_mode,
    nlink: f_nlink,
    uname: f_uname,
    gname: f_gname,
    size:  f_size,
    date:  f_date,
    name:  f_name,
  }

  # File.readlink(path) 
  # setuid?(path)
  # setgid?(path)
  # sticky?(path)
  # umask
  #  FileTest.symlink?(outfile) 

end


# 改善余地：ls -s の値の 2倍になってるようだが理屈がわからない
puts sprintf("total %d", (block_total / 2).to_i)
stats.each do |s|
  puts sprintf("%s%s %*s %*s %*s %*s %s %s",
               s[:type], s[:mode], len_nlink, s[:nlink], len_uname, s[:uname], len_gname, s[:gname], len_size, s[:size], s[:date], s[:name])
end

end

def print_dirs(dir, files)
  print_files(dir, files)
end

end
# ----------------------------------------------------------------------
class Column_Printer

def print_files(files)
  return nil if (files.length == 0)
  if (STDOUT.isatty)
    # 画面表示
    to_display(files)
  else 
    # パイプやリダイレクト
    to_file(files)
  end
end

def to_file(files)
  files.each do |f|
    puts f
  end
end

def to_display(files)

  # ターミナルの幅と最大長のファイル名を元に計算して出力
  #  空白は最小 2文字
  margin_base = 2
  screen_width = `tput cols`.to_i

    no_row = calc_rownum(files, screen_width, margin_base)

  # row_ary は名前が変か？
  row_ary = []
  files.each_slice(no_row) { |ary|
    row_ary << ary
  }

  #  p screen_width
  #  p no_row

  # margin はそのカラムの最大ファイル長 - 自身のファイル長 + col_margin
  for index_row in (0..no_row-1) do

    #  p ' ---'
    #  print index_row, max_length


    for row in row_ary do
      #    p row
      max_length = row.max_by{ |item| item.to_s.length }.length

      margin_length = margin_base + max_length
      print row[index_row].to_s.ljust(margin_length)
    end
    print "\n"

  end

end

def print_dirs(dir, files)
  print_files(files)
end

end
# ----------------------------------------------------------------------
def get_file_list(path_ary)
  files = []
  dirs  = []
  errors = []
  path_ary.each do |path|


    require "pathname"
    pname = Pathname.new(path).expand_path

    # path をディレクトリと想定しているか？同名のファイルが存在した場合のため
    directory_path = (path[-1, 1] == "/") ? true : false

    # 上位ディレクトリの展開可/不可
    prev_dir_executable = true

    # 改善余地：path が同じでも毎回全体をチェックするので非効率
    pname.descend {|pitem|

      #p pitem

      # 上位ディレクトリが展開不可ならアクセス不可エラー
      if(!prev_dir_executable)
        errors << ["e001", path]
        break
      end

      if (pitem.file?)
        if (directory_path)
          errors << ["e004", path]
          break
        else
          files << path
          break
        end
      end
      
      if (pitem.directory?)
        # 最下位のディレクトリ？
        if (pitem.eql?(pname))
          if (!pitem.readable? || !prev_dir_executable)
            errors << ["e003", path]
            break
          end
          dirs << [path, Dir.entries(path)]
          if (!pitem.executable?)
            Dir.entries(path).each do |item|
              errors << ["e001", path + ((path[-1, 1] == "/") ? item.to_s : "/" + item.to_s)]
            end
          end
        end
        prev_dir_executable = pitem.executable?
      end

      if (!pitem.file? && !pitem.directory?)
        errors << ["e002", path]
        break
      end

    }


  end

  return files, dirs, errors

end

# ----------------------------------------------------------------------
ERRMSG = {
  "e001" => "ls: cannot access " + "%s" + ": Permission denied",
  "e002" => "ls: cannot access " + "%s" + ": No such file or directory",
  "e003" => "ls: cannot open directory " + "%s" + ": Permission denied",
  "e004" => "ls: cannot open directory " + "%s" + ": Not a directory",
}

def print_errors(errors)

  errors.each do |error|
    STDERR.puts sprintf(ERRMSG[error[0]], error[1].to_s) if (ERRMSG.has_key?(error[0]))
  end

end

# ----------------------------------------------------------------------


options, path_ary = args_parse
files, dirs, errors = get_file_list(path_ary)

# オプションの処理
if (!options.include?("a"))
  # dirs のファイル一覧からドットファイルを削除
  dirs.each do |item|
    item[1].delete_if { |item| item =~ /^\..*/}
  end
end

if (options.include?("r"))
  files.sort! {|a, b| b <=> a }
  dirs.sort! {|a, b| b[0] <=> a[0] }
  dirs.each do |item|
    item[1].sort! {|a, b| b <=> a }
  end
else
  files.sort!
  dirs.sort!
  dirs.each do |item|
    item[1].sort!
  end
end

printer = Column_Printer.new
if (options.include?("l"))
  printer = List_Printer.new
end


# 結果表示
# 改善余地：結果表示のロジックが複雑なのは files, dirs, errors の持ち方に問題があるのでは？
print_errors(errors.select { |e| e[0] == "e001" }.sort_by(&:last))
print_errors(errors.select { |e| e[0] == "e004" }.sort_by(&:last))
print_errors(errors.select { |e| e[0] == "e002" })

# ファイル一覧を処理
if (files.length > 0)
  printer.print_files(files)

# この後に表示するものがある場合改行する
  e003_ary = errors.select { |e| e[0] == "e003" }
  if (e003_ary.length > 0 || dirs.length > 0)
    puts ""
  end

end

# ファイル一覧に内容が無くパスとファイル一覧のセットが一個だけならそれをファイル一覧として処理
# かつ、エラーが無ければ
if (dirs.length == 1 && files.length == 0 && errors.length == 0)
  printer.print_dirs(dirs[0][0], dirs[0][1])
end

print_errors(errors.select { |e| e[0] == "e003" }.sort_by(&:last))

# パスとファイル一覧のセットが複数あればパスを表示してファイル一覧を処理をセット分繰り返す
# dirs.length == 1 でも表示する
if !(dirs.length == 1 && files.length == 0 && errors.length == 0)
  if (dirs.length)
    dirs.each_with_index do |dir, i|
      puts "" if (i != 0)
      puts dir[0].to_s + ":"
      printer.print_dirs(dir[0], dir[1])
    end
  end
end

__END__
