#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

def args_parse
  options = ""
  paths   = []
  end_option = false



  for arg in ARGV
    if (arg.to_s == "--")
      end_option = true
      next
    end

    if (!end_option)
      if (arg.slice(0, 1) == "-" && arg.length > 1)
        options += arg
      else
        paths << arg
      end
    else
      paths << arg
    end
  end

  paths << "./" if (paths.length == 0)
  return options, paths

end

# ----------------------------------------------------------------------

def calc_rownum(files, screen_width, col_margin)

  # 行数 1 から最大ファイル数までで画面幅に収まる最小行数を求める
  no_row = 0
  for no_row in  1..files.length do

    #  p '---'
    #  p no_row

    overflow = false
    row_ary = []
    files.each_slice(no_row) { |ary|
      row_ary << ary
    }

    for index_row in (0..no_row-1) do
      length_row = 0
      for row in row_ary do
        length_row += row[index_row] ? row[index_row].to_s.length + col_margin : 0
      end

      #    p screen_width, length_row

      if (length_row > screen_width)
        overflow = true
        break
      end
      
    end

    if (!overflow)
      break
    end
    
  end

  return no_row

end

# ----------------------------------------------------------------------
class List_Printer

require 'etc'
require 'date'

FTYPE = {
  "file"             => "-",
  "directory"        => "d",
  "characterSpecial" => "c",
  "blockSpecial"     => "b",
  "fifo"             => "p",
  "link"             => "l",
  "socket"           => "s",
}

FMODE = {
  "7" => "rwx",
  "6" => "rw-",
  "5" => "r-x",
  "4" => "r--",
  "3" => "-wx",
  "2" => "-w-",
  "1" => "--x",
  "0" => "---",
}

def print_files(dir = "", files)

if (files.length == 0)
  puts "total 0"
  return nil
end

# ディレクトリの末尾を / にする
if (dir != "")
  dir += (dir[-1, 1] == "/") ? "" : "/"
end

# 改善余地：ファイルにアクセス可能かテスト

# ブロック数トータルを表示
# 改善余地：ls -s の値の 2倍になってるらしいが理屈がわからない
block_total = (files.map { |item| File.stat(dir.to_s + item.to_s).blocks }.sum / 2)
puts sprintf("total %d", block_total.to_i)

# 最大表示文字数取得
#stat.nlink
#stat.uid, stat.gid
#stat.size

# 変換
#mode



files.each do |item|

f = dir.to_s + item.to_s

stat = File.stat(f)
f_name = item
if (File.ftype(f) == "link")
  stat = File.lstat(f)
  f_name = item.to_s + " -> " + File.readlink(f)
end

f_type = (FTYPE.has_key?(File.ftype(f))) ? FTYPE[File.ftype(f)] : " "

f_mode = FMODE[stat.mode.to_s(8)[-3, 1]] + FMODE[stat.mode.to_s(8)[-2, 1]] + FMODE[stat.mode.to_s(8)[-1, 1]]
case stat.mode.to_s(8)[-4, 1]
when "1"
  # sticky bit
  f_mode[-1, 1] = "t"
when "2"
  # setgid
  f_mode[-4, 1] = "s"
when "4"
  # setuid
  f_mode[-7, 1] = "s"
end

date_format = ((Date.today - stat.mtime.to_date).abs > 181) ? "%b %e %_5Y" : "%b %e %H:%M"
f_date = stat.mtime.strftime(date_format)

  puts sprintf("%s%s %s %s %s %s %s %s", f_type, f_mode, stat.nlink, Etc.getpwuid(stat.uid).name, Etc.getgrgid(stat.gid).name, stat.size, f_date, f_name)

# File.readlink(path) 
# setuid?(path)
# setgid?(path)
# sticky?(path)
# umask
#  FileTest.symlink?(outfile) 

end

end

def print_dirs(dir, files)
  print_files(dir, files)
end

end
# ----------------------------------------------------------------------
class Column_Printer

def print_files(files)

  return nil if (files.length == 0)

  # ターミナルの幅と最大長のファイル名を元に計算して出力
  #  空白は最小 2文字
  margin_base = 2
  screen_width = `tput cols`.to_i

  # パイプやリダイレクトなら行数はファイル数、そうでなければ画面幅で行数計算
  no_row = files.length
  if (STDOUT.isatty)
    # margin_base で計算してちゃダメでは？ ←最大長のファイルの行もテストするから大丈夫なはず                                                   
    no_row = calc_rownum(files, screen_width, margin_base)
  end

  # row_ary は名前が変か？
  row_ary = []
  files.each_slice(no_row) { |ary|
    row_ary << ary
  }

  #  p screen_width
  #  p no_row

  # margin はそのカラムの最大ファイル長 - 自身のファイル長 + col_margin
  for index_row in (0..no_row-1) do

    #  p ' ---'
    #  print index_row, max_length


    for row in row_ary do
      #    p row
      max_length = row.max_by{ |item| item.to_s.length }.length

      margin_length = margin_base + max_length
      print row[index_row].to_s.ljust(margin_length)
    end
    print "\n"

  end

end

def print_dirs(dir, files)
  print_files(files)
end

end
# ----------------------------------------------------------------------
def get_file_list(path_ary)
  files = []
  dirs  = []
  errors = []
  path_ary.each do |path|


    require "pathname"
    pname = Pathname.new(path).expand_path

    # path をディレクトリと想定しているか？同名のファイルが存在した場合のため
    directory_path = (path[-1, 1] == "/") ? true : false

    # 上位ディレクトリの展開可/不可
    prev_dir_executable = true

    # 改善余地：path が同じでも毎回全体をチェックするので非効率
    pname.descend {|pitem|

      #p pitem

      # 上位ディレクトリが展開不可ならアクセス不可エラー
      if(!prev_dir_executable)
        errors << ["e001", path]
        break
      end

      if (pitem.file?)
        if (directory_path)
          errors << ["e004", path]
          break
        else
          files << path
          break
        end
      end
      
      if (pitem.directory?)
        # 最下位のディレクトリ？
        if (pitem.eql?(pname))
          if (!pitem.readable? || !prev_dir_executable)
            errors << ["e003", path]
            break
          end
          dirs << [path, Dir.entries(path)]
          if (!pitem.executable?)
            Dir.entries(path).each do |item|
              errors << ["e001", path + ((path[-1, 1] == "/") ? item.to_s : "/" + item.to_s)]
            end
          end
        end
        prev_dir_executable = pitem.executable?
      end

      if (!pitem.file? && !pitem.directory?)
        errors << ["e002", path]
        break
      end

    }


  end

  return files, dirs, errors

end

# ----------------------------------------------------------------------
ERRMSG = {
  "e001" => "ls: cannot access " + "%s" + ": Permission denied",
  "e002" => "ls: cannot access " + "%s" + ": No such file or directory",
  "e003" => "ls: cannot open directory " + "%s" + ": Permission denied",
  "e004" => "ls: cannot open directory " + "%s" + ": Not a directory",
}

def print_errors(errors)

  errors.each do |error|
    puts sprintf(ERRMSG[error[0]], error[1].to_s) if (ERRMSG.has_key?(error[0]))
  end

end

# ----------------------------------------------------------------------


options, path_ary = args_parse
files, dirs, errors = get_file_list(path_ary)

# オプションの処理
if (!options.include?("a"))
  # dirs のファイル一覧からドットファイルを削除
  dirs.each do |item|
    item[1].delete_if { |item| item =~ /^\..*/}
  end
end

if (options.include?("r"))
  files.sort! {|a, b| b <=> a }
  dirs.sort! {|a, b| b[0] <=> a[0] }
  dirs.each do |item|
    item[1].sort! {|a, b| b <=> a }
  end
else
  files.sort!
  dirs.sort!
  dirs.each do |item|
    item[1].sort!
  end
end

printer = Column_Printer.new
if (options.include?("l"))
  printer = List_Printer.new
end


# 結果表示
# 改善余地：結果表示のロジックが複雑なのは files, dirs, errors の持ち方に問題があるのでは？
print_errors(errors.select { |e| e[0] == "e001" }.sort_by(&:last))
print_errors(errors.select { |e| e[0] == "e004" }.sort_by(&:last))
print_errors(errors.select { |e| e[0] == "e002" })

# ファイル一覧を処理
if (files.length > 0)
  printer.print_files(files)

# この後に表示するものがある場合改行する
  e003_ary = errors.select { |e| e[0] == "e003" }
  if (e003_ary.length > 0 || dirs.length > 0)
    puts ""
  end

end

# ファイル一覧に内容が無くパスとファイル一覧のセットが一個だけならそれをファイル一覧として処理
# かつ、エラーが無ければ
if (dirs.length == 1 && files.length == 0 && errors.length == 0)
  printer.print_dirs(dirs[0][0], dirs[0][1])
end

print_errors(errors.select { |e| e[0] == "e003" }.sort_by(&:last))

# パスとファイル一覧のセットが複数あればパスを表示してファイル一覧を処理をセット分繰り返す
# dirs.length == 1 でも表示する
if !(dirs.length == 1 && files.length == 0 && errors.length == 0)
  if (dirs.length)
    dirs.each_with_index do |dir, i|
      puts "" if (i != 0)
      puts dir[0].to_s + ":"
      printer.print_dirs(dir[0], dir[1])
    end
  end
end

__END__
