#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

def args_parse
  options = ""
  paths   = []
  end_option = false



  for arg in ARGV
    if (arg.to_s == '--')
      end_option = true
      next
    end

    if (!end_option)
      if (arg.slice(0, 1) == '-' && arg.length > 1)
        options += arg
      else
        paths << arg
      end
    else
      paths << arg
    end
  end

  return options, paths

end

# ----------------------------------------------------------------------

def calc_rownum(files, screen_width, col_margin)

  # 行数 1 から最大ファイル数までで画面幅に収まる最小行数を求める
  no_row = 0
  for no_row in  1..files.length do

    #  p '---'
    #  p no_row

    overflow = false
    row_ary = []
    files.each_slice(no_row) { |ary|
      row_ary << ary
    }

    for index_row in (0..no_row-1) do
      length_row = 0
      for row in row_ary do
        length_row += row[index_row] ? row[index_row].to_s.length + col_margin : 0
      end

      #    p screen_width, length_row

      if (length_row > screen_width)
        overflow = true
        break
      end
      
    end

    if (!overflow)
      break
    end
    
  end

  return no_row

end

# ----------------------------------------------------------------------
def print_column(files)

  # ターミナルの幅と最大長のファイル名を元に計算して出力
  #  空白は最小 2文字
  margin_base = 2
  screen_width = `tput cols`.to_i

  # パイプやリダイレクトなら行数はファイル数、そうでなければ画面幅で行数計算
  no_row = files.length
  if STDOUT.isatty
    # margin_base で計算してちゃダメでは？ ←最大長のファイルの行もテストするから大丈夫なはず                                                   
    no_row = calc_rownum(files, screen_width, margin_base)
  end

  # row_ary は名前が変か？
  row_ary = []
  files.each_slice(no_row) { |ary|
    row_ary << ary
  }

#  p screen_width
#  p no_row

  # margin はそのカラムの最大ファイル長 - 自身のファイル長 + col_margin
  for index_row in (0..no_row-1) do

    #  p ' ---'
    #  print index_row, max_length


    for row in row_ary do
      #    p row
      max_length = row.max_by{ |item| item.to_s.length }.length

=begin
         for row_item in row do
           max_length = row_item.to_s.length > max_length ? row_item.to_s.length : max_length
         end
=end
      margin_length = margin_base + max_length
      print row[index_row].to_s.ljust(margin_length)
    end
    print "\n"

  end

end


# ----------------------------------------------------------------------
options, path_ary = args_parse

#p options
#p path_ary

#files = Dir.entries(path_ary[0])
#files = Dir.glob(path_ary[0])

files = []
dirs  = []
path_ary.each do |path|
  if (FileTest.file? path)
    files << path
  elsif (FileTest.directory? path)
    dirs << [path, Dir.entries(path)]
  else
    puts "ls: cannot access " + path.to_s + ": No such file or directory"
  end
end

# まずファイル一覧を処理
if (files.length > 0)
  print_column(files.sort)
end

# ファイル一覧に内容が無くパスとファイル一覧のセットが一個だけならそれをファイル一覧として処理
if (files.length == 0 && dirs.length == 1)
  print_column(dirs[0][1].sort)
end

# パスとファイル一覧のセットが複数あればパスを表示してファイル一覧を処理をセット分繰り返す
# so-to, kaigyou
for dir in dirs do
  puts dir[0].to_s + ":"
  print_column(dir[1].sort)
end


__END__

=begin
# file name generator
files = []
10.times do |i|
files << "oioi" + i.to_s #rand(15).to_i.to_s
end
#lengths = files.map{|file| file.to_s.length}
=end


__END__

no_row = calc_rownum(files, screen_width, margin_base)

row_ary = []
files.each_slice(no_row) { |ary|
  row_ary << ary
}

p screen_width
p no_row

for index_row in (0..no_row-1) do
  length_row = 0
  for row in row_ary do
    print row[index_row].to_s + "  "
  end
  print "\n"
end

# ----------------------------------------------------------------------

def args_parse
  # オプションをパース
  #  a r l のみ残すという処理は要らない、同じものが複数あってもかまわない
  #  一つの文字列に入れておいて存在するか？で判定
  # パスをパース
  #  配列に格納、単純にソートするだけでは ls と同じにならない！ファイル、ディレクトリの順では？
  #   ファイルの配列とディレクトリの配列に分けては？

  options = ""
  paths   = []
  for arg in ARGV
    if arg.slice(0, 1) == '-'
      options += arg
    else
      paths << arg
    end
  end 

  p options
  for path in paths.sort
    p path
  end

end

def get_filelist 
  # path のファイル一覧取得して配列に格納
  # path が存在しなかったらエラー表示しなければならないが？
  files = Dir.entries('.')

  # オプションに a が無ければ ^\.* を配列から削除
  # オプションに r があれば配列を逆順ソート
  # オプションに l がなければターミナルの幅と最大長のファイル名を元に計算して出力
  # オプションに l があればファイル属性を取得して整形して出力

  for item in files.sort {|a, b| b <=> a }
    puts item
  end

  p format("%0*d",8,123456)

end


def max_indexes(lengths)
  # ボツ：表示するファイル並び順が横で考えていたが、実際は縦だったので不要
  # len の最大値を求め、要素の len が最大値と同じインデックスを配列に入れていく←最大長のファイル名のインデックス
  # lengths に要素が一つでもある限り return null はあり得ない
  max_len = lengths.max
  indexes = []
  lengths.each_with_index do |len, i|
    if (len == max_len)
      indexes << i
    end
  end
  return indexes
end

def calculate_columns
  
  maxlen_indexs = max_indexes(lengths)

  # 状況表示
  for file in files
    puts file
  end
  for idx in maxlen_indexs
    p idx
  end

  # カラム数決定ロジック
  # 間違った！表示するファイル並び順が横で考えていたが、実際は縦だった！
  idx = maxlen_indexs[0] # まずは一個でロジック考える←複数に発展させて関数化

  col_min = num_files
  col_max = 0

  (0..idx).each do |start_idx| # 可能性として 0 から idx までが開始となり得る
    p "start", start_idx
    row_length = 0
    cols = 0
    (start_idx..num_files-1).each do |i|  # 可能性として 0 から num_files-1 までが一行に収まる場合があり得る
      row_length += lengths[i] + col_margin
      cols += 1
      if (row_length >= screen_width)
        if (i >= idx)
          if (cols > col_max)
            col_max = cols.dup
          end
          if (cols < col_min)
            col_min = cols.dup
          end
          p "width", screen_width
          p "rowlen", row_length
          p "cols", cols
        end
        break
      end
    end
  end

  p "max", col_max
  p "min", col_min

end
