#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

def args_parse
  options = ""
  paths   = []
  end_option = false



  for arg in ARGV
    if (arg.to_s == "--")
      end_option = true
      next
    end

    if (!end_option)
      if (arg.slice(0, 1) == "-" && arg.length > 1)
        options += arg
      else
        paths << arg
      end
    else
      paths << arg
    end
  end

  paths << "./" if (paths.length == 0)
  return options, paths

end

# ----------------------------------------------------------------------

def calc_rownum(files, screen_width, col_margin)

  # 行数 1 から最大ファイル数までで画面幅に収まる最小行数を求める
  no_row = 0
  for no_row in  1..files.length do

    #  p '---'
    #  p no_row

    overflow = false
    row_ary = []
    files.each_slice(no_row) { |ary|
      row_ary << ary
    }

    for index_row in (0..no_row-1) do
      length_row = 0
      for row in row_ary do
        length_row += row[index_row] ? row[index_row].to_s.length + col_margin : 0
      end

      #    p screen_width, length_row

      if (length_row > screen_width)
        overflow = true
        break
      end
      
    end

    if (!overflow)
      break
    end
    
  end

  return no_row

end

# ----------------------------------------------------------------------
def print_column(files)

  # ターミナルの幅と最大長のファイル名を元に計算して出力
  #  空白は最小 2文字
  margin_base = 2
  screen_width = `tput cols`.to_i

  # パイプやリダイレクトなら行数はファイル数、そうでなければ画面幅で行数計算
  no_row = files.length
  if (STDOUT.isatty)
    # margin_base で計算してちゃダメでは？ ←最大長のファイルの行もテストするから大丈夫なはず                                                   
    no_row = calc_rownum(files, screen_width, margin_base)
  end

  # row_ary は名前が変か？
  row_ary = []
  files.each_slice(no_row) { |ary|
    row_ary << ary
  }

#  p screen_width
#  p no_row

  # margin はそのカラムの最大ファイル長 - 自身のファイル長 + col_margin
  for index_row in (0..no_row-1) do

    #  p ' ---'
    #  print index_row, max_length


    for row in row_ary do
      #    p row
      max_length = row.max_by{ |item| item.to_s.length }.length

=begin
         for row_item in row do
           max_length = row_item.to_s.length > max_length ? row_item.to_s.length : max_length
         end
=end
      margin_length = margin_base + max_length
      print row[index_row].to_s.ljust(margin_length)
    end
    print "\n"

  end

end


# ----------------------------------------------------------------------
def get_files(path_ary)
files = []
dirs  = []
errors = []
path_ary.each do |path|

=begin
  if (!FileTest.exist? path)
    puts "ls: cannot access " + path.to_s + ": No such file or directory"
    break
  end

  if (!FileTest.readable? path)
    puts "ls: cannot access " + path.to_s + ": You don't have permission"
    break
  end

  if (pname.file?)
    files << path
  elsif (pname.directory?)
    dirs << [path, Dir.entries(path)]
  else
    puts "ls: cannot access " + path.to_s + ": No such file or directory"
  end

=end

# https://www.ibm.com/developerworks/jp/linux/library/l-lpic1-104-5/index.html
# ディレクトリーの場合の読み取り権限は、読み取り権限を持つユーザーがディレクトリーの内容を一覧表示することを許可します。
# 実行権限は、ユーザーがディレクトリーに入って任意のサブディレクトリーにアクセスすることを許可します。
# ディレクトリーに対する実行権限が与えられていなければ、ディレクトリー内のファイルシステム・オブジェクトにアクセスすることはできません。ディレクトリーに対する読み取り権限が与えられていない場合、ディレクトリー内のファイルシステム・オブジェクトはディレクトリー・リストに表示されませんが、それでもディスク上でのオブジェクトのフル・パスを知っている限りは、オブジェクトにアクセスすることができます。

# path を / で区切る→ items
# 最下位がファイルかディレクトリか検査？
# items を上位から順に処理
#  ファイルだったら存在チェック A
#  ディレクトリだったら r チェック、その下にまだディレクトリがあればさらに x チェック
#    を開くことが出来ません: 許可がありません
# 最下位がディレクトリの場合
#  x チェック NG ならその中のファイル一覧は表示しつつ、それぞれの権限エラーも表示
#    にアクセスできません: 許可がありません
# 最下位がファイルの場合
#  その上のディレクトリが x チェック NG なら権限エラー
#    にアクセスできません: 許可がありません
#
# メッセージもリターンして後で表示する必要ありそう。表示順番の規則がわからない
# 
#

    require "pathname"
    pname = Pathname.new(path).expand_path

# path をディレクトリと想定しているか？同名のファイルが存在した場合のため
directory_path = (path[-1, 1] == "/") ? true : false

# 上位ディレクトリの展開可/不可
prev_dir_executable = true

# 改善余地：path が同じでも毎回全体をチェックするので非効率
pname.descend {|pitem|

#p pitem

# 上位ディレクトリが展開不可ならアクセス不可エラー
      if(!prev_dir_executable)
        errors << ["e001", path]
        break
      end

    if (pitem.file?)
      if (directory_path)
        errors << ["e004", path]
        break
      else
        files << path
        break
      end
    end
    
    if (pitem.directory?)
# 最下位のディレクトリ？
      if (pitem.eql?(pname))
        if (!pitem.readable? || !prev_dir_executable)
          errors << ["e003", path]
          break
        end
        dirs << [path, Dir.entries(path)]
        if (!pitem.executable?)
          Dir.entries(path).each do |item|
            errors << ["e001", path + "/" + item.to_s]
          end
        end
      end
      prev_dir_executable = pitem.executable?
    end

    if (!pitem.file? && !pitem.directory?)
      errors << ["e002", path]
      break
    end

}

# 同名のファイルがあるとき
# ls: cannot access rls/: Not a directory

# e001       errors << [path, "ls: cannot access " + path.to_s + ": Permission denied"]
# e002       errors << [path, "ls: cannot access " + path.to_s + ": No such file or directory"]
# e003       errors << [path, "ls: cannot open directory " + path.to_s + ": Permission denied"]

#executable?
#readable?
#exist?

end

return files, dirs, errors


=begin
begin
rescue Errno::EACCES
    puts "ls: cannot access " + path.to_s + ": You don't have permission"
end
=end

end

# ----------------------------------------------------------------------
  ERRMSG = {
     "e001" => "ls: cannot access " + "%s" + ": Permission denied",
     "e002" => "ls: cannot access " + "%s" + ": No such file or directory",
     "e003" => "ls: cannot open directory " + "%s" + ": Permission denied",
     "e004" => "ls: cannot open directory " + "%s" + ": Not a directory",
 }

def print_errors(errors)

#  errors.sort_by(&:last).each do |error|
  errors.each do |error|
    puts sprintf(ERRMSG[error[0]], error[1].to_s) if (ERRMSG.has_key?(error[0]))
  end

end

# ----------------------------------------------------------------------
options, path_ary = args_parse
files, dirs, errors = get_files(path_ary)

print_errors(errors.select { |e| e[0] == "e001" }.sort_by(&:last))
print_errors(errors.select { |e| e[0] == "e004" }.sort_by(&:last))
print_errors(errors.select { |e| e[0] == "e002" })

# 改善余地：表示のロジックが複雑なのは files, dirs, errors の持ち方に問題があるのでは？

# とにかく files/dirs/errors 含めて length == 1 なら ファイル一覧表示、そうでなければ dir はパス表示＋ファイル一覧表示
# まずファイル一覧を処理
if (files.length > 0)
  print_column(files.sort)

e003_ary = errors.select { |e| e[0] == "e003" }
if (e003_ary.length > 0 || dirs.length > 0)
  puts ""
end

end

# ファイル一覧に内容が無くパスとファイル一覧のセットが一個だけならそれをファイル一覧として処理
# かつ、エラーが無ければ
if (dirs.length == 1 && files.length == 0 && errors.length == 0)
  print_column(dirs[0][1].sort)
end

print_errors(errors.select { |e| e[0] == "e003" }.sort_by(&:last))

# パスとファイル一覧のセットが複数あればパスを表示してファイル一覧を処理をセット分繰り返す
# dirs.length == 1 でも表示する
if !(dirs.length == 1 && files.length == 0 && errors.length == 0)
if (dirs.length)
  dirs.sort_by(&:first).each_with_index do |dir, i|
    puts "" if (i != 0)
    puts dir[0].to_s + ":"
    print_column(dir[1].sort)
  end
end
end

__END__

=begin
options, path_ary = args_parse
files, dirs, errors = get_files(path_ary)

print_errors(errors.select { |e| e[0] == "e001" })
print_errors(errors.select { |e| e[0] == "e004" })
print_errors(errors.select { |e| e[0] == "e002" })

# 改善余地：表示のロジックが複雑なのは files, dirs, errors の持ち方に問題があるのでは？

# とにかく files/dirs/errors 含めて length == 1 なら ファイル一覧表示、そうでなければ dir はパス表示＋ファイル一覧表示
# まずファイル一覧を処理
do_print_files = false
if (files.length > 0)
  print_column(files.sort)
  do_print_files = true
end

# ファイル一覧に内容が無くパスとファイル一覧のセットが一個だけならそれをファイル一覧として処理
# かつ、エラーが無ければ
if (dirs.length == 1 && !do_print_files && errors.length == 0)
  print_column(dirs[0][1].sort)
end

e003_ary = errors.select { |e| e[0] == "e003" }
if (e003_ary.length > 0 && do_print_files)
if (do_print_files)
  puts ""
end
print_errors(e003_ary)
end

# パスとファイル一覧のセットが複数あればパスを表示してファイル一覧を処理をセット分繰り返す
# dirs.length == 1 でも表示する
if !(dirs.length == 1 && !do_print_files && errors.length == 0)
if (dirs.length)
  dirs.sort_by(&:first).each_with_index do |dir, i|
    puts "" if (i != 0 || do_print_files)
    puts dir[0].to_s + ":"
    print_column(dir[1].sort)
  end
end
end
=end

=begin
# file name generator
files = []
10.times do |i|
files << "oioi" + i.to_s #rand(15).to_i.to_s
end
#lengths = files.map{|file| file.to_s.length}
=end


__END__

no_row = calc_rownum(files, screen_width, margin_base)

row_ary = []
files.each_slice(no_row) { |ary|
  row_ary << ary
}

p screen_width
p no_row

for index_row in (0..no_row-1) do
  length_row = 0
  for row in row_ary do
    print row[index_row].to_s + "  "
  end
  print "\n"
end

# ----------------------------------------------------------------------

def args_parse
  # オプションをパース
  #  a r l のみ残すという処理は要らない、同じものが複数あってもかまわない
  #  一つの文字列に入れておいて存在するか？で判定
  # パスをパース
  #  配列に格納、単純にソートするだけでは ls と同じにならない！ファイル、ディレクトリの順では？
  #   ファイルの配列とディレクトリの配列に分けては？

  options = ""
  paths   = []
  for arg in ARGV
    if (arg.slice(0, 1) == '-')
      options += arg
    else
      paths << arg
    end
  end 

  p options
  for path in paths.sort
    p path
  end

end

def get_filelist 
  # path のファイル一覧取得して配列に格納
  # path が存在しなかったらエラー表示しなければならないが？
  files = Dir.entries('.')

  # オプションに a が無ければ ^\.* を配列から削除
  # オプションに r があれば配列を逆順ソート
  # オプションに l がなければターミナルの幅と最大長のファイル名を元に計算して出力
  # オプションに l があればファイル属性を取得して整形して出力

  for item in files.sort {|a, b| b <=> a }
    puts item
  end

  p format("%0*d",8,123456)

end


def max_indexes(lengths)
  # ボツ：表示するファイル並び順が横で考えていたが、実際は縦だったので不要
  # len の最大値を求め、要素の len が最大値と同じインデックスを配列に入れていく←最大長のファイル名のインデックス
  # lengths に要素が一つでもある限り return null はあり得ない
  max_len = lengths.max
  indexes = []
  lengths.each_with_index do |len, i|
    if (len == max_len)
      indexes << i
    end
  end
  return indexes
end

def calculate_columns
  
  maxlen_indexs = max_indexes(lengths)

  # 状況表示
  for file in files
    puts file
  end
  for idx in maxlen_indexs
    p idx
  end

  # カラム数決定ロジック
  # 間違った！表示するファイル並び順が横で考えていたが、実際は縦だった！
  idx = maxlen_indexs[0] # まずは一個でロジック考える←複数に発展させて関数化

  col_min = num_files
  col_max = 0

  (0..idx).each do |start_idx| # 可能性として 0 から idx までが開始となり得る
    p "start", start_idx
    row_length = 0
    cols = 0
    (start_idx..num_files-1).each do |i|  # 可能性として 0 から num_files-1 までが一行に収まる場合があり得る
      row_length += lengths[i] + col_margin
      cols += 1
      if (row_length >= screen_width)
        if (i >= idx)
          if (cols > col_max)
            col_max = cols.dup
          end
          if (cols < col_min)
            col_min = cols.dup
          end
          p "width", screen_width
          p "rowlen", row_length
          p "cols", cols
        end
        break
      end
    end
  end

  p "max", col_max
  p "min", col_min

end
